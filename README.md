Вариант задания: Объявление и определение структуры на языке PHP:

struct Employee{
    string $firstName;
    string $lastName;
    int $salary;
    bool $fullTime;
};

Целью работы было: Изучить назначение синтаксического анализатора. Спроектировать алгоритм и выполнить программную реализацию парсера.

В соответствии с вариантом задания было сделано:

1. Разработана автоматная грамматика.
2. Спроектирован граф конечного автомата.
3. Выполнена программная реализация алгоритма работы конечного автомата.
4. Встроена разработанная программа в интерфейс текстового редактора, созданного на первой лабораторной работе.
 
Результатом анализа правильной строки является вывод сообщения об отсутствии ошибок. 
Анализатор работает в паре с ранее разработанным лексическим анализатором, принимая на вход последовательность токенов и проверяя их соответствие заданной грамматике. 
Если анализируемая строка содержит ошибки, то выводятся сообщения о них, неверный фрагмент (символ) и его местоположение.

Что добавлено
Класс SyntaxAnalyzer - основной класс, реализующий логику синтаксического анализатора:
1. Автоматная грамматика для анализа структуры.
2. Анализатор интегрируется с графическим интерфейсом через метод PrintResultsToRichTextBox, который: Отображает ошибки с цветовым выделением в RichTextBox. Группирует множественные ошибки. Поддерживает форматированный вывод.
3. Проверка баланса скобок и наличия полей.
4. Подробные сообщения об ошибках.

Примеры допустимых строк: 

struct Person {
    string $name;
    int $age;
};

struct Product {
    string $title;
    double $price;
    bool $inStock;
};

Грамматика является автоматной.
1.	< START > → ‘STRUCT’ < SPACE >
2.	< SPACE > → ‘   ‘→ < Name >
3.	< Name > → ‘letter’ → < NameRem >
4.	< NameRem > → ‘letter’ → < NameRem >
5.	< NameRem >    → < Digit > < NameRem >
6.	< NameRem > → ‘{‘  < TYPE >
7.	< TYPE > → ‘string’ → < SPACE >
8.	< TYPE > → ‘int’ → < SPACE >
9.	< TYPE > → ‘bool’ → < SPACE >
10.	< TYPE > → ‘float’ → < SPACE >
11.	< TYPE > -> ‘double’ → < SPACE >
12.	< SPACE > → ‘   ‘→ < SPACE > 
13.	< SPACE > → ‘$’ → < StrRem >
14.	< StrRem > → symbol < StrRem >
15.	< StrRem > → ‘;’ < TYPE >
16.	< StrRem > → ‘;’ < END >
17.	< END>  → ‘}’ FINAL
18.	FINAL → ‘;’‹ E › → ‹ ; ›
    
•	‹ Digit › → “0” | “1” | “2” | “3” | “4” | “5” | “6” | “7” | “8” | “9”

•	‹ Letter › → “a” | “b” | “c” | ... | “z” | “A” | “B” | “C” | ... | “Z”

Следуя введенному формальному определению грамматики, представим G[‹Def›] ее составляющими:

Z = ‹ START ›;

VT = {a, b, c, ..., z, A, B, C, ..., Z, _,:, =, +, -, ;, ., 0, 1, 2, ..., 9};

VN ={‹ START ›,‹ SPACE ›,‹ Name ›,‹ NameRem ›, ‹ TYPE ›,‹ StrRem ›,‹ END ›,‹ FINAL ›,‹ Digit ›,‹ Letter ›}.


Правила (1) – (18) для G[‹Def›] реализованы на графе (см. рисунок 1).

Сплошные стрелки на графе характеризуют синтаксически верный разбор; пунктирные символизируют состояние ошибки (ERROR); 

Состояние 11 символизирует успешное завершение разбора.

Рисунок 1

![Граф](https://github.com/user-attachments/assets/b0d057eb-606e-4c19-830c-7b73f42bc062)

Тестовые примеры:

![Рисунок3](https://github.com/user-attachments/assets/f2456ff3-6462-43f8-9e36-11da31258631)

![Рисунок4](https://github.com/user-attachments/assets/ca3ebaee-5754-4bb1-99b2-295de4227d76)


Отчет РГЗ: 

[РГЗ_АП226_Шолдышева.docx](https://github.com/user-attachments/files/20183252/_.226_.docx)



